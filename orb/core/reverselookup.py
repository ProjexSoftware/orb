from projex.lazymodule import lazy_import
from .collector import Collector

orb = lazy_import('orb')

class ReverseLookup(Collector):
    def __json__(self):
        output = super(ReverseLookup, self).__json__()
        output['model'] = self.__reference
        output['target'] = self.targetColumn().field()
        return output

    def __init__(self, from_column='', reference='', target='', removeAction='unset', **options):
        if from_column:
            reference, _, target = from_column.partition('.')

        options['model'] = reference
        super(ReverseLookup, self).__init__(**options)

        if removeAction not in ('unset', 'delete'):
            raise orb.errors.ValidationError('The remove action must be either "unset" or "delete".')

        # custom options
        self.__reference = reference
        self.__removeAction = removeAction
        self.__target = target

    def add_record(self, source_record, target_record, **context):
        target_record.set(self.targetColumn(), source_record)
        target_record.save()
        return True

    def create_record(self, source_record, values, **context):
        values.setdefault(self.targetColumn().name(), source_record)
        return self.reference_model().create(values, **context)

    def collect(self, record, **context):
        if not record.is_record():
            return orb.Collection()
        else:
            model = self.reference_model()

            # create the pipe query
            q  = orb.Query(model, self.__target) == record

            context['where'] = q & context.get('where')
            records = model.select(**context)
            return records.bind_collector(self).bind_source_record(record)

    def collect_expand(self, query, parts, **context):
        rmodel = self.reference_model()
        sub_q = query.copy()
        sub_q._Query__column = '.'.join(parts[1:])
        sub_q._Query__model = rmodel
        return rmodel.select(columns=[self.targetColumn()], where=sub_q)

    def copy(self):
        out = super(ReverseLookup, self).copy()
        out._ReverseLookup__reference = self.__reference
        out._ReverseLookup__target = self.__target
        return out

    def removeAction(self):
        """
        Defines the action that should be taken when a model is removed from the collection generated
        by this reverse lookup.  The default action is 'unset', which will simply de-reference the source
        model from the target.  If you set the action to 'delete', then the target model will be fully removed
        from the database when being removed.

        :return:  <str>
        """
        return self.__removeAction

    def reference_model(self):
        schema = orb.system.schema(self.__reference)
        if schema is not None:
            return schema.model()
        else:
            raise orb.errors.ModelNotFound(schema=self.__reference)

    def remove_record(self, source_record, target_record, **context):
        target_record.set(self.targetColumn(), None)
        target_record.save()
        return 1

    def setRemoveAction(self, action):
        """
        Sets the remove action that should be taken when a model is removed from the collection generated by
        this reverse lookup.  Valid actions are "unset" or "delete", any other values will raise an exception.

        :param action: <str>
        """
        if action not in ('unset', 'delete'):
            raise orb.errors.ValidationError('The remove action must be either "unset" or "delete"')
        else:
            self.__removeAction = action

    def targetColumn(self):
        schema = orb.system.schema(self.__reference)
        try:
            return schema.column(self.__target)
        except AttributeError:
            raise orb.errors.ModelNotFound(schema=self.__reference)

    def update_records(self, source_record, collection, collection_ids, **context):
        orb_context = orb.Context(**context)
        target_column = self.targetColumn()
        target_model = target_column.schema().model()

        q = orb.Query(target_column) == source_record
        q &= orb.Query(target_model).notIn(collection_ids)

        # determine the reverse lookups to remove from this collection
        remove_records = target_model.select(where=q, context=orb_context)

        # check the remove action to determine how to handle this situation
        if self.removeAction() == 'delete':
            remove_records.delete()

        else:
            for record in remove_records:
                record.set(target_model, None)
                record.save()

        # determine the new records to add to this collection
        if collection_ids:
            q = orb.Query(target_model).in_(collection_ids)
            q &= (orb.Query(target_column) != source_record) | (orb.Query(target_column) == None)

            add = target_model.select(where=q, context=orb_context)
            for record in add:
                record.set(target_column, source_record)
                record.save()